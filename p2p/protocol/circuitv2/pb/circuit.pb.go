// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.6.1
// source: github.com/libp2p/go-libp2p/p2p/protocol/circuitv2/pb/circuit.proto

package circuit_pb

import (
	base64 "encoding/base64"
	fmt "fmt"
	io "io"
	strconv "strconv"
	strings "strings"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
)

type Status int32

const (
	// zero value field required for proto3 compatibility
	Status_UNUSED                  Status = 0
	Status_OK                      Status = 100
	Status_RESERVATION_REFUSED     Status = 200
	Status_RESOURCE_LIMIT_EXCEEDED Status = 201
	Status_PERMISSION_DENIED       Status = 202
	Status_CONNECTION_FAILED       Status = 203
	Status_NO_RESERVATION          Status = 204
	Status_MALFORMED_MESSAGE       Status = 400
	Status_UNEXPECTED_MESSAGE      Status = 401
)

// Enum value maps for Status.
var (
	Status_name = map[int32]string{
		0:   "UNUSED",
		100: "OK",
		200: "RESERVATION_REFUSED",
		201: "RESOURCE_LIMIT_EXCEEDED",
		202: "PERMISSION_DENIED",
		203: "CONNECTION_FAILED",
		204: "NO_RESERVATION",
		400: "MALFORMED_MESSAGE",
		401: "UNEXPECTED_MESSAGE",
	}
	Status_value = map[string]int32{
		"UNUSED":                  0,
		"OK":                      100,
		"RESERVATION_REFUSED":     200,
		"RESOURCE_LIMIT_EXCEEDED": 201,
		"PERMISSION_DENIED":       202,
		"CONNECTION_FAILED":       203,
		"NO_RESERVATION":          204,
		"MALFORMED_MESSAGE":       400,
		"UNEXPECTED_MESSAGE":      401,
	}
)

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}

func (x Status) String() string {
	name, valid := Status_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type HopMessage_Type int32

const (
	HopMessage_RESERVE HopMessage_Type = 0
	HopMessage_CONNECT HopMessage_Type = 1
	HopMessage_STATUS  HopMessage_Type = 2
)

// Enum value maps for HopMessage_Type.
var (
	HopMessage_Type_name = map[int32]string{
		0: "RESERVE",
		1: "CONNECT",
		2: "STATUS",
	}
	HopMessage_Type_value = map[string]int32{
		"RESERVE": 0,
		"CONNECT": 1,
		"STATUS":  2,
	}
)

func (x HopMessage_Type) Enum() *HopMessage_Type {
	p := new(HopMessage_Type)
	*p = x
	return p
}

func (x HopMessage_Type) String() string {
	name, valid := HopMessage_Type_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type StopMessage_Type int32

const (
	StopMessage_CONNECT StopMessage_Type = 0
	StopMessage_STATUS  StopMessage_Type = 1
)

// Enum value maps for StopMessage_Type.
var (
	StopMessage_Type_name = map[int32]string{
		0: "CONNECT",
		1: "STATUS",
	}
	StopMessage_Type_value = map[string]int32{
		"CONNECT": 0,
		"STATUS":  1,
	}
)

func (x StopMessage_Type) Enum() *StopMessage_Type {
	p := new(StopMessage_Type)
	*p = x
	return p
}

func (x StopMessage_Type) String() string {
	name, valid := StopMessage_Type_name[int32(x)]
	if valid {
		return name
	}
	return strconv.Itoa(int(x))
}

type HopMessage struct {
	unknownFields []byte
	// This field is marked optional for backwards compatibility with proto2.
	// Users should make sure to always set this.
	Type        *HopMessage_Type `protobuf:"varint,1,opt,name=type,proto3,oneof" json:"type,omitempty"`
	Peer        *Peer            `protobuf:"bytes,2,opt,name=peer,proto3,oneof" json:"peer,omitempty"`
	Reservation *Reservation     `protobuf:"bytes,3,opt,name=reservation,proto3,oneof" json:"reservation,omitempty"`
	Limit       *Limit           `protobuf:"bytes,4,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	Status      *Status          `protobuf:"varint,5,opt,name=status,proto3,oneof" json:"status,omitempty"`
}

func (x *HopMessage) Reset() {
	*x = HopMessage{}
}

func (*HopMessage) ProtoMessage() {}

func (x *HopMessage) GetType() HopMessage_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return HopMessage_RESERVE
}

func (x *HopMessage) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *HopMessage) GetReservation() *Reservation {
	if x != nil {
		return x.Reservation
	}
	return nil
}

func (x *HopMessage) GetLimit() *Limit {
	if x != nil {
		return x.Limit
	}
	return nil
}

func (x *HopMessage) GetStatus() Status {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Status_UNUSED
}

type StopMessage struct {
	unknownFields []byte
	// This field is marked optional for backwards compatibility with proto2.
	// Users should make sure to always set this.
	Type   *StopMessage_Type `protobuf:"varint,1,opt,name=type,proto3,oneof" json:"type,omitempty"`
	Peer   *Peer             `protobuf:"bytes,2,opt,name=peer,proto3,oneof" json:"peer,omitempty"`
	Limit  *Limit            `protobuf:"bytes,3,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	Status *Status           `protobuf:"varint,4,opt,name=status,proto3,oneof" json:"status,omitempty"`
}

func (x *StopMessage) Reset() {
	*x = StopMessage{}
}

func (*StopMessage) ProtoMessage() {}

func (x *StopMessage) GetType() StopMessage_Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return StopMessage_CONNECT
}

func (x *StopMessage) GetPeer() *Peer {
	if x != nil {
		return x.Peer
	}
	return nil
}

func (x *StopMessage) GetLimit() *Limit {
	if x != nil {
		return x.Limit
	}
	return nil
}

func (x *StopMessage) GetStatus() Status {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return Status_UNUSED
}

type Peer struct {
	unknownFields []byte
	// This field is marked optional for backwards compatibility with proto2.
	// Users should make sure to always set this.
	Id    []byte   `protobuf:"bytes,1,opt,name=id,proto3,oneof" json:"id,omitempty"`
	Addrs [][]byte `protobuf:"bytes,2,rep,name=addrs,proto3" json:"addrs,omitempty"`
}

func (x *Peer) Reset() {
	*x = Peer{}
}

func (*Peer) ProtoMessage() {}

func (x *Peer) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *Peer) GetAddrs() [][]byte {
	if x != nil {
		return x.Addrs
	}
	return nil
}

type Reservation struct {
	unknownFields []byte
	// This field is marked optional for backwards compatibility with proto2.
	// Users should make sure to always set this.
	Expire  *uint64  `protobuf:"varint,1,opt,name=expire,proto3,oneof" json:"expire,omitempty"`  // Unix expiration time (UTC)
	Addrs   [][]byte `protobuf:"bytes,2,rep,name=addrs,proto3" json:"addrs,omitempty"`           // relay addrs for reserving peer
	Voucher []byte   `protobuf:"bytes,3,opt,name=voucher,proto3,oneof" json:"voucher,omitempty"` // reservation voucher
}

func (x *Reservation) Reset() {
	*x = Reservation{}
}

func (*Reservation) ProtoMessage() {}

func (x *Reservation) GetExpire() uint64 {
	if x != nil && x.Expire != nil {
		return *x.Expire
	}
	return 0
}

func (x *Reservation) GetAddrs() [][]byte {
	if x != nil {
		return x.Addrs
	}
	return nil
}

func (x *Reservation) GetVoucher() []byte {
	if x != nil {
		return x.Voucher
	}
	return nil
}

type Limit struct {
	unknownFields []byte
	Duration      *uint32 `protobuf:"varint,1,opt,name=duration,proto3,oneof" json:"duration,omitempty"` // seconds
	Data          *uint64 `protobuf:"varint,2,opt,name=data,proto3,oneof" json:"data,omitempty"`         // bytes
}

func (x *Limit) Reset() {
	*x = Limit{}
}

func (*Limit) ProtoMessage() {}

func (x *Limit) GetDuration() uint32 {
	if x != nil && x.Duration != nil {
		return *x.Duration
	}
	return 0
}

func (x *Limit) GetData() uint64 {
	if x != nil && x.Data != nil {
		return *x.Data
	}
	return 0
}

func (m *HopMessage) CloneVT() *HopMessage {
	if m == nil {
		return (*HopMessage)(nil)
	}
	r := new(HopMessage)
	r.Peer = m.Peer.CloneVT()
	r.Reservation = m.Reservation.CloneVT()
	r.Limit = m.Limit.CloneVT()
	if rhs := m.Type; rhs != nil {
		tmpVal := *rhs
		r.Type = &tmpVal
	}
	if rhs := m.Status; rhs != nil {
		tmpVal := *rhs
		r.Status = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *HopMessage) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *StopMessage) CloneVT() *StopMessage {
	if m == nil {
		return (*StopMessage)(nil)
	}
	r := new(StopMessage)
	r.Peer = m.Peer.CloneVT()
	r.Limit = m.Limit.CloneVT()
	if rhs := m.Type; rhs != nil {
		tmpVal := *rhs
		r.Type = &tmpVal
	}
	if rhs := m.Status; rhs != nil {
		tmpVal := *rhs
		r.Status = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *StopMessage) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Peer) CloneVT() *Peer {
	if m == nil {
		return (*Peer)(nil)
	}
	r := new(Peer)
	if rhs := m.Id; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Id = tmpBytes
	}
	if rhs := m.Addrs; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.Addrs = tmpContainer
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Peer) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Reservation) CloneVT() *Reservation {
	if m == nil {
		return (*Reservation)(nil)
	}
	r := new(Reservation)
	if rhs := m.Expire; rhs != nil {
		tmpVal := *rhs
		r.Expire = &tmpVal
	}
	if rhs := m.Addrs; rhs != nil {
		tmpContainer := make([][]byte, len(rhs))
		for k, v := range rhs {
			tmpBytes := make([]byte, len(v))
			copy(tmpBytes, v)
			tmpContainer[k] = tmpBytes
		}
		r.Addrs = tmpContainer
	}
	if rhs := m.Voucher; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.Voucher = tmpBytes
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Reservation) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *Limit) CloneVT() *Limit {
	if m == nil {
		return (*Limit)(nil)
	}
	r := new(Limit)
	if rhs := m.Duration; rhs != nil {
		tmpVal := *rhs
		r.Duration = &tmpVal
	}
	if rhs := m.Data; rhs != nil {
		tmpVal := *rhs
		r.Data = &tmpVal
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = make([]byte, len(m.unknownFields))
		copy(r.unknownFields, m.unknownFields)
	}
	return r
}

func (m *Limit) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *HopMessage) EqualVT(that *HopMessage) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Type, that.Type; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Peer.EqualVT(that.Peer) {
		return false
	}
	if !this.Reservation.EqualVT(that.Reservation) {
		return false
	}
	if !this.Limit.EqualVT(that.Limit) {
		return false
	}
	if p, q := this.Status, that.Status; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *HopMessage) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*HopMessage)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *StopMessage) EqualVT(that *StopMessage) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Type, that.Type; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !this.Peer.EqualVT(that.Peer) {
		return false
	}
	if !this.Limit.EqualVT(that.Limit) {
		return false
	}
	if p, q := this.Status, that.Status; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *StopMessage) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*StopMessage)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Peer) EqualVT(that *Peer) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Id, that.Id; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if len(this.Addrs) != len(that.Addrs) {
		return false
	}
	for i, vx := range this.Addrs {
		vy := that.Addrs[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Peer) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Peer)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Reservation) EqualVT(that *Reservation) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Expire, that.Expire; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Addrs) != len(that.Addrs) {
		return false
	}
	for i, vx := range this.Addrs {
		vy := that.Addrs[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	if p, q := this.Voucher, that.Voucher; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Reservation) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Reservation)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}
func (this *Limit) EqualVT(that *Limit) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if p, q := this.Duration, that.Duration; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Data, that.Data; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Limit) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Limit)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the Status to JSON.
func (x Status) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), Status_name)
}

// MarshalText marshals the Status to text.
func (x Status) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), Status_name)), nil
}

// MarshalJSON marshals the Status to JSON.
func (x Status) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Status from JSON.
func (x *Status) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(Status_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Status enum: %v", err)
		return
	}
	*x = Status(v)
}

// UnmarshalText unmarshals the Status from text.
func (x *Status) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), Status_value)
	if err != nil {
		return err
	}
	*x = Status(i)
	return nil
}

// UnmarshalJSON unmarshals the Status from JSON.
func (x *Status) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the HopMessage_Type to JSON.
func (x HopMessage_Type) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), HopMessage_Type_name)
}

// MarshalText marshals the HopMessage_Type to text.
func (x HopMessage_Type) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), HopMessage_Type_name)), nil
}

// MarshalJSON marshals the HopMessage_Type to JSON.
func (x HopMessage_Type) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the HopMessage_Type from JSON.
func (x *HopMessage_Type) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(HopMessage_Type_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Type enum: %v", err)
		return
	}
	*x = HopMessage_Type(v)
}

// UnmarshalText unmarshals the HopMessage_Type from text.
func (x *HopMessage_Type) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), HopMessage_Type_value)
	if err != nil {
		return err
	}
	*x = HopMessage_Type(i)
	return nil
}

// UnmarshalJSON unmarshals the HopMessage_Type from JSON.
func (x *HopMessage_Type) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// NOTE: protobuf-go-lite json only supports proto3 and not proto3opt (optional fields).

// MarshalProtoJSON marshals the StopMessage_Type to JSON.
func (x StopMessage_Type) MarshalProtoJSON(s *json.MarshalState) {
	s.WriteEnumString(int32(x), StopMessage_Type_name)
}

// MarshalText marshals the StopMessage_Type to text.
func (x StopMessage_Type) MarshalText() ([]byte, error) {
	return []byte(json.GetEnumString(int32(x), StopMessage_Type_name)), nil
}

// MarshalJSON marshals the StopMessage_Type to JSON.
func (x StopMessage_Type) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the StopMessage_Type from JSON.
func (x *StopMessage_Type) UnmarshalProtoJSON(s *json.UnmarshalState) {
	v := s.ReadEnum(StopMessage_Type_value)
	if err := s.Err(); err != nil {
		s.SetErrorf("could not read Type enum: %v", err)
		return
	}
	*x = StopMessage_Type(v)
}

// UnmarshalText unmarshals the StopMessage_Type from text.
func (x *StopMessage_Type) UnmarshalText(b []byte) error {
	i, err := json.ParseEnumString(string(b), StopMessage_Type_value)
	if err != nil {
		return err
	}
	*x = StopMessage_Type(i)
	return nil
}

// UnmarshalJSON unmarshals the StopMessage_Type from JSON.
func (x *StopMessage_Type) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// NOTE: protobuf-go-lite json only supports proto3 and not proto3opt (optional fields).

// NOTE: protobuf-go-lite json only supports proto3 and not proto3opt (optional fields).

// NOTE: protobuf-go-lite json only supports proto3 and not proto3opt (optional fields).

// NOTE: protobuf-go-lite json only supports proto3 and not proto3opt (optional fields).

func (m *HopMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HopMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *HopMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Status != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.Limit != nil {
		size, err := m.Limit.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.Reservation != nil {
		size, err := m.Reservation.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		size, err := m.Peer.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StopMessage) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopMessage) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *StopMessage) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Status != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != nil {
		size, err := m.Limit.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Peer != nil {
		size, err := m.Peer.MarshalToSizedBufferVT(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Peer) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id != nil {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reservation) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reservation) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Reservation) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Voucher != nil {
		i -= len(m.Voucher)
		copy(dAtA[i:], m.Voucher)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Voucher)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Expire != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Expire))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Limit) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Limit) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Limit) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if m.Data != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Data))
		i--
		dAtA[i] = 0x10
	}
	if m.Duration != nil {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(*m.Duration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HopMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Type))
	}
	if m.Peer != nil {
		l = m.Peer.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Reservation != nil {
		l = m.Reservation.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Status != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Status))
	}
	n += len(m.unknownFields)
	return n
}

func (m *StopMessage) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Type))
	}
	if m.Peer != nil {
		l = m.Peer.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Limit != nil {
		l = m.Limit.SizeVT()
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Status != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Status))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Peer) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(m.Id)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Addrs) > 0 {
		for _, b := range m.Addrs {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *Reservation) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expire != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Expire))
	}
	if len(m.Addrs) > 0 {
		for _, b := range m.Addrs {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if m.Voucher != nil {
		l = len(m.Voucher)
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *Limit) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Duration != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Duration))
	}
	if m.Data != nil {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(*m.Data))
	}
	n += len(m.unknownFields)
	return n
}

func (x Status) MarshalProtoText() string {
	return x.String()
}
func (x HopMessage_Type) MarshalProtoText() string {
	return x.String()
}
func (x *HopMessage) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("HopMessage { ")
	if x.Type != nil {
		sb.WriteString(" type: ")
		sb.WriteString(x.Type.String())
	}
	if x.Peer != nil {
		sb.WriteString(" peer: ")
		sb.WriteString(x.Peer.MarshalProtoText())
	}
	if x.Reservation != nil {
		sb.WriteString(" reservation: ")
		sb.WriteString(x.Reservation.MarshalProtoText())
	}
	if x.Limit != nil {
		sb.WriteString(" limit: ")
		sb.WriteString(x.Limit.MarshalProtoText())
	}
	if x.Status != nil {
		sb.WriteString(" status: ")
		sb.WriteString(x.Status.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *HopMessage) String() string {
	return x.MarshalProtoText()
}
func (x StopMessage_Type) MarshalProtoText() string {
	return x.String()
}
func (x *StopMessage) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("StopMessage { ")
	if x.Type != nil {
		sb.WriteString(" type: ")
		sb.WriteString(x.Type.String())
	}
	if x.Peer != nil {
		sb.WriteString(" peer: ")
		sb.WriteString(x.Peer.MarshalProtoText())
	}
	if x.Limit != nil {
		sb.WriteString(" limit: ")
		sb.WriteString(x.Limit.MarshalProtoText())
	}
	if x.Status != nil {
		sb.WriteString(" status: ")
		sb.WriteString(x.Status.String())
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *StopMessage) String() string {
	return x.MarshalProtoText()
}
func (x *Peer) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Peer { ")
	if len(x.Id) > 0 {
		sb.WriteString(" id: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Id))
		sb.WriteString("\"")
	}
	if len(x.Addrs) > 0 {
		sb.WriteString(" addrs: [")
		for i, v := range x.Addrs {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Peer) String() string {
	return x.MarshalProtoText()
}
func (x *Reservation) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Reservation { ")
	if x.Expire != nil {
		sb.WriteString(" expire: ")
		sb.WriteString(strconv.FormatUint(uint64(*x.Expire), 10))
	}
	if len(x.Addrs) > 0 {
		sb.WriteString(" addrs: [")
		for i, v := range x.Addrs {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	if len(x.Voucher) > 0 {
		sb.WriteString(" voucher: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Voucher))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Reservation) String() string {
	return x.MarshalProtoText()
}
func (x *Limit) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Limit { ")
	if x.Duration != nil {
		sb.WriteString(" duration: ")
		sb.WriteString(strconv.FormatUint(uint64(*x.Duration), 10))
	}
	if x.Data != nil {
		sb.WriteString(" data: ")
		sb.WriteString(strconv.FormatUint(uint64(*x.Data), 10))
	}
	sb.WriteString("}")
	return sb.String()
}
func (x *Limit) String() string {
	return x.MarshalProtoText()
}
func (m *HopMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HopMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HopMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v HopMessage_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= HopMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reservation == nil {
				m.Reservation = &Reservation{}
			}
			if err := m.Reservation.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Limit{}
			}
			if err := m.Limit.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v Status
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopMessage) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v StopMessage_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= StopMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &Peer{}
			}
			if err := m.Peer.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Limit == nil {
				m.Limit = &Limit{}
			}
			if err := m.Limit.UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v Status
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, make([]byte, postIndex-iNdEx))
			copy(m.Addrs[len(m.Addrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reservation) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reservation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reservation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expire", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Expire = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, make([]byte, postIndex-iNdEx))
			copy(m.Addrs[len(m.Addrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voucher", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voucher = append(m.Voucher[:0], dAtA[iNdEx:postIndex]...)
			if m.Voucher == nil {
				m.Voucher = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Limit) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return protobuf_go_lite.ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Duration = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protobuf_go_lite.ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Data = &v
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
